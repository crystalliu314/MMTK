/**
 * MMTK UI
 *
 * Simple UI sketch to plot the output data and show state of buttons and stuff
 *
 * Requires:
 * - ControlP5 library (install from processing)
 * 
 * This is based on Real Time Plotter Library from https://github.com/sebnil/RealtimePlotter
 */
 
// import libraries
import java.awt.Frame;
import java.awt.BorderLayout;
import controlP5.*; // http://www.sojamo.de/libraries/controlP5/
import processing.serial.*;
import java.util.Arrays;
PFont f;

// If you want to debug the plotter without using a real serial port set this to true
boolean mockupSerial = true;

// Serial Setup
String serialPortName;
Serial serialPort;  // Create object from Serial class

// interface stuff
ControlP5 cp5;

// Settings for the plotter are saved in this file
JSONObject plotterConfigJSON;

// ***********************
// ** Drawing Constants **
// ***********************

// Screen
int[] screenSize = {1080, 720};

// XY Plot
int[] XYplotOrigin = {100, 150};
int[] XYplotSize = {600, 500};
int XYplotColor = color(20, 20, 200);

// Button Indicators
int buttonActiveColor = color(120,255,120);
int buttonInactiveColor = color(255,120,120);
int buttonBorderColor = 10;
int[] buttonIndicatorSize = {50,50};

int [] buttonForwardOrigin = {800,650};
int [] buttonBackOrigin = {850,650};
int [] buttonTareOrigin = {900,650};
int [] buttonStartOrigin = {950,650};
int [] buttonAuxOrigin = {1000,650};
int buttonTextColor = color(0,0,0);

// eStop Indicator
int[] eStopIndicatorOrigin = {500, 600};
int[] eStopIndicatorSize = {50,250};
int eStopActiveColor = color(250,0,0);
int eStopInactiveColor = color(0,250,0);

// motor stall indicator
int[] stallIndicatorOrigin = {500, 600};
int[] stallIndicatorSize = {50,250};
int stallActiveColor = color(250,0,0);
int stallInactiveColor = color(0,250,0);

// Generate the plot
int[] XYplotFloatDataDims = {4, 10000};
int[] XYplotIntDataDims = {5, 10000};

Graph XYplot = new Graph(XYplotOrigin[0], XYplotOrigin[1], XYplotSize[0], XYplotSize[1], XYplotColor);
float[][] XYplotFloatData = new float[XYplotFloatDataDims[0]][XYplotFloatDataDims[1]];
int[][] XYplotIntData = new int[XYplotIntDataDims[0]][XYplotIntDataDims[1]];
// This value grows and is used for slicing
int XYplotCurrentSize = 0;


// ************************
// ** Variables for Data **
// ************************


float speed = 0.0;
float position = 0.0;
float loadCell = 0.0;
int feedBack = 0;
int MMTKState = 0;
int eStop = 0;
int stall = 0;
int direction = 0;
float inputVolts = 12.0;

int btBak = 0;
int btFwd = 0;
int btTare = 0;
int btStart = 0;
int btAux = 0;


// helper for saving the executing path
String topSketchPath = "";

// Log File
PrintWriter logFile;

// MMTK logo image
PImage mmtkLogo;


void settings() {
    size(screenSize[0], screenSize[1]);
}

void setup() 
{
  // Create a new file in the sketch directory
  String logFileName = "logs/MMTK" 
                       +" " + String.format("%04d", year()) 
                       + "-" + String.format("%02d", month()) 
                       + "-" + String.format("%02d", day()) 
                       + " " + String.format("%02d", hour()) 
                       + "-" + String.format("%02d", minute()) 
                       + "-" + String.format("%02d", second()) 
                       + ".txt";
  try {
   logFile = createWriter(logFileName); 
  }
  catch (Exception e) {
    System.out.println(e);
  }
  
  logFile.println("Started Log File:     " + logFileName);
  logFile.flush(); // Writes the remaining data to the file
  
  // settings save file
  topSketchPath = sketchPath();
  plotterConfigJSON = loadJSONObject(topSketchPath+"/plotter_config.json");
  
  surface.setTitle("Realtime plotter");
  
  // settings save file
  topSketchPath = sketchPath();
  plotterConfigJSON = loadJSONObject(topSketchPath+"/plotter_config.json");

  // gui
  cp5 = new ControlP5(this);
  f = createFont("Arial",10,true); 
  
  // init charts
  setChartSettings();
  
  
  // start serial communication
  //serialPortName = Serial.list()[0];
  if (!mockupSerial) {
    //String serialPortName = Serial.list()[3];
    serialPort = new Serial(this, serialPortName, 115200);
  }
  else
    serialPort = null;

  
  // Draw MMTK Logo image
  mmtkLogo = loadImage("/images/mmtk-logo.png");

}








// *******************************
// ** MAIN DRAW LOOP START HERE **
// *******************************


byte[] inBuffer = new byte[1000]; // holds serial message
int i = 0; // loop variable
int j = 0;

void draw()
{  
  
  setChartSettings();
  /* Read serial and update values */
  if (mockupSerial || serialPort.available() > 0) {
    String myString = "";
    if (!mockupSerial) {
      try {
        serialPort.readBytesUntil('\r', inBuffer);
      }
      catch (Exception e) {
      }
      myString = new String(inBuffer);
    }
    else {
      myString = mockupSerialFunction();
    }

    // Print out the data for debugging and logging
    System.out.println(myString);
    logFile.println(myString);
    
    
    if (myString.contains("TARE")) {
      // This is a tare frame, empty the array and ignore it
      // Also ignore the next line with indices
      serialPort.readBytesUntil('\r', inBuffer);
      XYplotCurrentSize = 0;
      
    } else {
      // split the string at delimiter (space)
      String[] tempData = split(myString, ' ');   

      // build the arrays for bar charts and line graphs
      if (tempData.length == 15) {
        // This is a normal data frame
        // SPEED POSITION LOADCELL FEEDBACK_COUNT STATE ESTOP STALL DIRECTION INPUT_VOLTAGE BT_FWD BT_BAK BT_TARE BT_START BT_AUX and a space
        
        try {
          speed = Float.parseFloat(trim(tempData[0]));
          position = Float.parseFloat(trim(tempData[1]));
          loadCell = Float.parseFloat(trim(tempData[2]));
          feedBack = Integer.parseInt(trim(tempData[3]));
          MMTKState = Integer.parseInt(trim(tempData[4]));
          eStop = Integer.parseInt(trim(tempData[5]));
          stall = Integer.parseInt(trim(tempData[6]));
          direction = Integer.parseInt(trim(tempData[7]));
          inputVolts = Float.parseFloat(trim(tempData[8]));
          
          btBak = Integer.parseInt(trim(tempData[9]));
          btFwd = Integer.parseInt(trim(tempData[10]));
          btTare = Integer.parseInt(trim(tempData[11]));
          btStart = Integer.parseInt(trim(tempData[12]));
          btAux = Integer.parseInt(trim(tempData[13]));
        }
        catch (NumberFormatException e) {
          System.out.println(e);
        }
        
      } else {
        // invalid message ignore it
        System.out.println("Corrupted Serial Message Frame Ignored");
      }
      
      // If the current data is longer than our buffer
      // Have to expand the buffer and continue
      if (XYplotCurrentSize >= XYplotIntData[0].length) {
        System.out.println("=========== expand buffer ==============");
        int newLength = XYplotIntDataDims[1] + XYplotIntData[0].length;
        int[][] tempIntData = new int[XYplotIntDataDims[0]][newLength];
        float[][] tempFloatData = new float[XYplotFloatDataDims[0]][newLength];

        // Copy data to this bigger array
        for (i=0; i<tempIntData.length; i++) {
          System.arraycopy(XYplotIntData[i], 0, tempIntData[i], 0, XYplotIntData[i].length);    
        }
        for (i=0; i<XYplotFloatData.length; i++) {
          System.arraycopy(XYplotFloatData[i], 0, tempFloatData[i], 0, XYplotFloatData[i].length);    
        }
        XYplotIntData = tempIntData;
        XYplotFloatData = tempFloatData;
      }
    
      // update the data buffer        
        
        
        XYplotFloatData[0][XYplotCurrentSize] = speed;
        XYplotFloatData[1][XYplotCurrentSize] = position;
        XYplotFloatData[2][XYplotCurrentSize] = loadCell;
        XYplotFloatData[3][XYplotCurrentSize] = inputVolts;
        
        XYplotIntData[0][XYplotCurrentSize] = feedBack;
        XYplotIntData[1][XYplotCurrentSize] = MMTKState;
        XYplotIntData[2][XYplotCurrentSize] = eStop;
        XYplotIntData[3][XYplotCurrentSize] = stall;
        XYplotIntData[4][XYplotCurrentSize] = direction;
        
        XYplotCurrentSize ++;
        
    }
      
      
    
    }

    
    
  
  // draw the bar chart
  background(200); 
  
  
  // Draw the MMTK Logo
  image(mmtkLogo, 0, 0, 300, 100);

  // Copy data to plot into new array for plotting
  float[] plotDisplacement = Arrays.copyOfRange(XYplotFloatData[1], 0, XYplotCurrentSize);
  float[] plotForce = Arrays.copyOfRange(XYplotFloatData[2], 0, XYplotCurrentSize);
  

  // draw the line graphs
  XYplot.DrawAxis();
  XYplot.GraphColor = XYplotColor;
  XYplot.DotXY(plotDisplacement, plotForce);
  
  
  
  // Draw / update buttons
  
  // Buttons
  stroke(buttonBorderColor);
  fill(buttonActiveColor);
  
  textFont(f);
  textAlign(LEFT);
  
  if (btFwd >= 1) {
    fill(buttonActiveColor);
  } else {
    fill(buttonInactiveColor);
  }
  rect(buttonForwardOrigin[0], buttonForwardOrigin[1], buttonIndicatorSize[0], buttonIndicatorSize[1]);
  fill(buttonTextColor);
  text("Forward\nButton", buttonForwardOrigin[0]+10, buttonForwardOrigin[1]+buttonIndicatorSize[1]/2-5);
  
  if (btBak >= 1) {
    fill(buttonActiveColor);
  } else {
    fill(buttonInactiveColor);
  }
  rect(buttonBackOrigin[0], buttonBackOrigin[1],  buttonIndicatorSize[0], buttonIndicatorSize[1]);
  fill(buttonTextColor);
  text("Back\nButton", buttonBackOrigin[0]+10, buttonBackOrigin[1]+buttonIndicatorSize[1]/2-5);
  
  if (btTare >= 1) {
    fill(buttonActiveColor);
  } else {
    fill(buttonInactiveColor);
  }
  rect(buttonTareOrigin[0], buttonTareOrigin[1], buttonIndicatorSize[0], buttonIndicatorSize[1]);
  fill(buttonTextColor);
  text("Tare\nButton", buttonTareOrigin[0]+10, buttonTareOrigin[1]+buttonIndicatorSize[1]/2-5);
  
  if (btStart >= 1) {
    fill(buttonActiveColor);
  } else {
    fill(buttonInactiveColor);
  }
  rect(buttonStartOrigin[0], buttonStartOrigin[1], buttonIndicatorSize[0], buttonIndicatorSize[1]);
  fill(buttonTextColor);
  text("Start\nButton", buttonStartOrigin[0]+10, buttonStartOrigin[1]+buttonIndicatorSize[1]/2-5);
  
  if (btAux >= 1) {
    fill(buttonActiveColor);
  } else {
    fill(buttonInactiveColor);
  }
  rect(buttonAuxOrigin[0], buttonAuxOrigin[1], buttonIndicatorSize[0], buttonIndicatorSize[1]);
  fill(buttonTextColor);
  text("Aux\nButton", buttonAuxOrigin[0]+10, buttonAuxOrigin[1]+buttonIndicatorSize[1]/2-5);
  
  
  
  // eStop and stall indicators
  if (stall >= 1) {
    fill(stallActiveColor);
  } else {
    fill(stallInactiveColor);
  }
  rect(stallIndicatorOrigin[0], stallIndicatorOrigin[1], stallIndicatorSize[0], stallIndicatorSize[1]);
  fill(buttonTextColor);
  text("Motor Stall Indicator", stallIndicatorOrigin[0]+10, stallIndicatorOrigin[1]+20);
  
  if (eStop >= 1) {
    fill(eStopActiveColor);
  } else {
    fill(eStopInactiveColor);
  }
  rect(eStopIndicatorOrigin[0], eStopIndicatorOrigin[1], eStopIndicatorSize[0], eStopIndicatorSize[1]);
  fill(buttonTextColor);
  text("Motor Stall Indicator", eStopIndicatorOrigin[0]+10, eStopIndicatorOrigin[1]+20);
  
}
















// *********************
// ** HELPER FUNCTIONS **
// **********************


// called each time the chart settings are changed by the user 
void setChartSettings() {
  XYplot.xLabel=" Displacment (mm) ";
  XYplot.yLabel=" Force (N) ";
  XYplot.Title="";  
  XYplot.xDiv=2;  
  XYplot.xMax=1000; 
  XYplot.xMin=-10;  
  XYplot.yMax=1000; 
  XYplot.yMin=-10;
}

// handle gui actions
void controlEvent(ControlEvent theEvent) {
  if (theEvent.isAssignableFrom(Textfield.class) || theEvent.isAssignableFrom(Toggle.class) || theEvent.isAssignableFrom(Button.class)) {
    String parameter = theEvent.getName();
    String value = "";
    if (theEvent.isAssignableFrom(Textfield.class))
      value = theEvent.getStringValue();
    else if (theEvent.isAssignableFrom(Toggle.class) || theEvent.isAssignableFrom(Button.class))
      value = theEvent.getValue()+"";

    plotterConfigJSON.setString(parameter, value);
    saveJSONObject(plotterConfigJSON, topSketchPath+"/plotter_config.json");
  }
  setChartSettings();
}

// get gui settings from settings file
String getPlotterConfigString(String id) {
  String r = "";
  try {
    r = plotterConfigJSON.getString(id);
  } 
  catch (Exception e) {
    r = "";
  }
  return r;
}
